
<div align="center">
  <a href="README.pt-br.md">
    <img src="https://img.shields.io/badge/lang-pt--br-green.svg" alt="PortuguÃªs">
  </a>
  <a href="README.md">
    <img src="https://img.shields.io/badge/lang-en-red.svg" alt="English">
  </a>
</div>

# Spring Secure Identity API

## Summary
Robust RESTful API for user management, focused on security and best development practices.
The application supports the complete management lifecycle (CRUD) with role-based access control (RBAC).

The system differentiates regular users (USER) from administrators (ADMIN), where only administrators have
privileges to remove users from the system and change permission levels.
Authentication is handled via JWT (JSON Web Token) with a Refresh Token strategy persisted in the database for enhanced security.

## Technologies Used

* **Languages:** Java 17
* **Framework:** Spring Boot 3
* **Security:** Spring Security + JWT (Auth0)
* **Database:** MySQL 8
* **ORM:** Hibernate / Spring Data JPA
* **Infrastructure:** Docker & Docker Compose
* **Tools:** Lombok, Maven
* **Documentation:** SpringDoc OpenAPI (Swagger UI)
* **Testing:** JUnit 5, Mockito
* **Logging:** SLF4J & Logback 

## Applied Studies

This project was developed with a strong focus on applying advanced Software Engineering and Security concepts:

* **Stateless & Stateful Authentication:** Hybrid implementation using Access Tokens (short-lived) and Refresh Tokens (long-lived and persisted in the database).
* **Layered Security:** Route protection via `SecurityFilterChain`, password encryption with BCrypt, and data validation using Bean Validation.
* **Global Error Handling:** Centralized exception handling with @RestControllerAdvice to standardize HTTP responses.
* **Automatic Auditing:** Use of JPA Auditing for automatic management of timestamps (createdAt, updatedAt) in entities.
* **Secrets Management:** Use of environment variables and placeholders (`${...}`) to avoid exposing sensitive credentials in the source code.
* **Containerization:** Portable development environment setup using Docker Compose (Application + Database).
* **Architecture:** Clear separation of responsibilities (Controller, Service, Repository, DTOs, and Entities).
* **Testing:** Implementation of unit and integration tests using JUnit 5 and Mockito.
* **Logging:** Logging implementation with SLF4J and Logback.

## Interactive Documentation

The project uses **Swagger UI** for endpoint documentation and interactive testing.
After starting the application, access:

ðŸ‘‰ **http://localhost:8081/swagger-ui.html**

There you can:
* View all available endpoints.
* Test requests (Login, Registration, Refresh) directly in the browser.
* Authenticate using the Authorize button (copy the token generated by the login endpoint).

## Installation and Execution

### Prerequisites
* Docker and Docker Compose installed.
* (Optional) Java 17 and Maven to run locally outside the container.

### Step 1: Environment Configuration (.env)
For security reasons, the project does not share real passwords. Create a `.env` file at the project root  
(where `docker-compose.yml` is located) with the following content:

```properties
# Database Configuration
MYSQL_DATABASE=ssi_db
MYSQL_ROOT_USERNAME=root
MYSQL_ROOT_PASSWORD=your_strong_password_here

JWT_SECRET=super_secret_key_to_generate_token

# Initial Admin Configuration (Seed)
ADMIN_EMAIL=admin@email.com
ADMIN_PASSWORD=admin
ADMIN_CREATE=true
```
> **Note:** When starting the application for the first time with `ADMIN_CREATE=true`, an administrator user will be
automatically created with the credentials defined in the `.env` file, allowing immediate access to protected routes.

### Step 2: Running with Docker (Recommended)

At the project root, run:

```docker
docker compose up --build
```

The API will be available at: http://localhost:8081

### Step 3: Running Locally (Without Docker)

If you want to run the application via an IDE (IntelliJ/Eclipse) and use Docker only for the database:

Start only the database:

```docker
docker compose up db -d
```

The application will automatically use the default development settings (localhost, user: root, pass: password)
defined in application.properties as a fallback.

